[{"id":"2e99a752c54d149ce68a60b00d3f322d","title":"飞书小组件开发总结","content":"开发文档1. 快速上手准备开发工作台小组件概述 - 开发指南 - 开发文档 - 飞书开放平台\n\n这个文档是开始准备开发需要看的，包括了开发前的一些准备工作，比如前期在开发者后台的配置，开发工具的下载。也提供了工作台小组件的框架生命周期，代码构成，基础能力等等，这部分开始了解即可，不用深究，写代码的时候再细看。\n开发者后台配置文档有部分不清楚，在此补充说明前提是应用和工作台小组件已经新建后\n新建应用 App Id 在这里展示\n工作台小组件 Block Id 在这里展示\n为保证开发时开发人员能及时看到效果，避免出现加载超时问题，需要在这里至少添加为测试人员\n\n\n开发者工具一定下载新版本，新版本比老版本好用很多\n\n2. 代码开发文档a. 配置参考 - 开发指南 - 开发文档 - 飞书开放平台\nb. 基础组件 - 客户端 API - 开发文档 - 飞书开放平台\n   以上两个文档都需要开发时候查看。\n\n第一个文档内容以及其下方内容包括了配置，代码构成，框架介绍，基本功能，前三个需要详细了解，其中代码构成和框架介绍下一大章具体介绍。\n第二个文档即之后内容介绍了开发可用的组件，封装好可以使用的 API，根据具体需求使用。\n有很多的组件和API，小组件和小程序是通用的（比如我开发中遇到的 login，canvas），但是在工作台开发文档里它并没有说明这一点（很不好的地方）。所以建议想要得到什么功能工作台文档没有找到就去小程序找找看看是否支持小组件，如果找不到提问飞书技术支持\n\n整体框架⻜书⼯作台开发使⽤的是其⾃研的框架，所以不⽀持很多库的导⼊。\n其框架可参考开发⽂档这⼀章节提供的⽂档，以下谈我⾃⼰理解。\n1. 代码结构代码结构分为视图层，逻辑层。\n视图层对应的语⾔为 TTML, TTSS (分别对应我们熟知的 HTML 和 CSS)，其中TTML⽀持了像列表渲染，条件渲染，数据绑定等这样的功能（写法⼗分类似于 Vue）。TTSS 则基本和 CSS ⼗分相近，采⽤ CSS ⽀持的写法（注意不⽀持 less 写法，所以嵌套写法是⾏不通的）。\n逻辑层⽤的就是 JS，⻜书⼯作台封装了 Block 和 Creator 。其中 Block 是⼩组件应⽤的数据载体，Creator 的主要功能是创建⼩组件应⽤的元信息（SourceMeta）和源数据（SourceData）传递给Block.Creator我没有使⽤暂时不做介绍，对于 Block，其结构设计和⽣命周期设计也是类似于 Vue框架的，展⽰如下。\n1234567891011121314151617181920212223242526272829303132333435363738Block(&#123;  data: &#123;    point: 1,  &#125;,  onLoad(options) &#123;    console.log(options.host, options.blockInfo);  &#125;,  onShow() &#123;      // 视图可见时执行  &#125;,  onHide() &#123;      // 视图隐藏时执行  &#125;,  onReady() &#123;      // 视图渲染完成时执行  &#125;,  onDestroy() &#123;      // Block销毁时执行  &#125;,  onResourceChange(sourceData) &#123;    // 有协同数据更新时执行，业务可以获取到相关数据信息进行一定的逻辑操作  &#125;,  onActivate(activeState)&#123;    // block 激活时执行    this.setData(activeState);  &#125;,  onInactivate()&#123;    // block 失活时执行    tt.saveState(&#123;      state: this.data,    &#125;);  &#125;,  methods: &#123;    onTap(e) &#123;      // invoked when user do some action    &#125;  &#125;,&#125;);\n\n组件使用这⾥我再贴⼀下组件的⽂档基础组件 - 客⼾端 API - 开发⽂档 - ⻜书开放平台。我这次开发主要⽤到的除了基础组件外就是图标组件，⽬前图表⻜书⼯作台⼩组件开发只⽀持使⽤ChartSpace组件（组件⽂档中打开图表开发⽂档）\n1. 图表绘制在⻜书⼯作台中需要使⽤ canvas 来绘制图表，canvas 绘制代码⽐较繁琐，⽂档中给出了⼀个图表⽰例，该⽰例⾥有封装好的 canvas 绘制，可以直接使⽤。ChartSpace 图表组件 - 客⼾端 API - 开发⽂档 - ⻜书开放平台\n注意到飞书最近可能收到比较多不好用的反馈，升级了 VChart，可见文档VChart 使用\n2. imageimage 不⽀持使⽤本地图⽚，只能使⽤⽹络图⽚或者符合 data:URL 协议的图⽚。\n3. 父子组件对应文档中的 template 和 import 组件，详见文档。但是目前子组件只能使用父组件传来的方法和数据进行展示，自己无法处理任何数据逻辑，必须是父组件处理好的。子组件无法给父组件传任何东西。\n客户端封装 API客户端封装了比较多的API供开发者使用，这里附上使用链接API简介 - 客户端 API - 开发文档 - 飞书开放平台。这一块文档描述很详细，没有什么问题，就是需要注意某些API小组件和小程序通用，但小组件中没有明确哪些共用，需要确认一下。\n其中关于发送网络请求中有一种封装好的promise版本下文介绍。\n发送请求由于官方没有对 request 进行 promise 的封装，下面列出一种封装方法。\n12345678910111213141516// 用于 API Promise 化function promisify() &#123;  if (tt.promises) &#123;    return;  &#125;  tt.promises = new Proxy(tt, &#123;    get(obj, api) &#123;      const fn = obj[api];      const isFunction = typeof fn === &#x27;function&#x27;;      const isSyncFunction = api.endsWith(&#x27;Sync&#x27;);      const isEventFunction = api.startsWith(&#x27;on&#x27;) || api.startsWith(&#x27;off&#x27;);      const isCreateFunction = api.startsWith(&#x27;create&#x27;);      if (!isFunction || isSyncFunction || isEventFunction || isCreateFunction) &#123;        return\n\n这样在代码初始执行引入的 promisify 方法就可实现 promise 的封装。\n\nrequest 请求坑点\n\n不支持 cookie，无法获取后端设置 cookie，也无法自行设置请求头的 cookie。（很重要，开发前一定要注意这点）\n移动端适配\nTTSS 移动端问题\n\n不支持 rem 适配（因为无法设置最外层 HTML 的 font-size）\n不支持任何视口单位\n不支持标签选择器\n不支持组选择器（比如这个代码）\n\n 1.a, .b &#123; color: red &#125; // 只有b类html元素受影响，a类不受影响\n\n\ndisplay 不去指定会默认为 display：auto（飞书自己定的一种写法），不设置宽高的话内容会被压缩没，所有内容默认一行内排列，有点类似 inline\n所有的元素都会默认加一个 border，会导致开发调试界面和最终结果界面不一致\n所有盒子默认是怪异盒模型\n\n\nJS 移动端遇到的问题\n\n在第一次加载页面时，import 的数据无法得到，刷新一次就可以拿到（不是浏览器支持问题，具体原因尚不清楚）\n\n\n\n","slug":"feishu","date":"2023-12-18T06:00:00.000Z","categories_index":"前端技术","tags_index":"飞书平台,工作台小组件","author_index":"Carlos Lee"},{"id":"848e7f65f11be9c581f104a5e89cadaa","title":"构建管理 menorepo","content":"使用 pnpm 管理 workspace\n下载 pnpm, 安装 father-build\n 12npm install -g pnpmpnpm i -D father-build\n\n启用 pnpm 的 workspace 功能\n根目录下新建 packages 文件夹，该文件夹下管理各个项目仓库。之后在根目录新建 pnpm-workspace.yaml 文件，在文件里指定工作目录，指定代码是\n12packages: - &#x27;packages/*&#x27;\n\n使用 changesets 管理版本\n\n\n\n安装 changesets 并初始化\n  12pnpm add -D @changesets/clipnpm changeset init\n\n使用 changesets\n首先在 package.json 文件中添加下方语句\n  12&quot;changeset&quot;: &quot;changeset&quot;&quot;version-packages&quot;: &quot;changeset version&quot;\n\n之后需要管理版本时按先后顺序执行这两个命令即可\n\n\n","slug":"menorepo","date":"2023-12-10T04:00:00.000Z","categories_index":"前端技术","tags_index":"pnpm,menorepo,changesets","author_index":"Carlos Lee"},{"id":"642d5527a23c1a254ea2226d6952428e","title":"npm 包开发流程","content":"Eslint、stylelint配置包开发编写对应依赖配置的npm包，之后发版到公司私有仓库下，由其他项目下载引入使用。公司统一npm包配置流程：\n\n设置npm镜像源为默认仓库使用命令\n1npm config set registry https://xxx(镜像源url)\n\n登录npm仓库使用 npm login 命令，输入账号，密码，邮箱完成登录\n\n初始化npm包使用 npm init 命令初始化 npm 包，根据终端提示构建 package.json 文件。\n\n编写npm包根据个人需求编写组件代码，可能引入其他依赖等。\n\n编写测试用例项目中编写测试用例，测试编写内容是否有效\n\n编写README.md文档编写该文档来说明该包的使用方法。\n\n发布 npm 包首先根目录写一个.npmrc文件，在文件中指定@it-fe域下包的对应地址，编写如下内容\n1@it-fe:registry=https://xxx(镜像源url)\n\n之后使用 npm publish 命令发布\n\n在其他项目下载并引入该包查看是否可以使用\n\n\nls-lint配置包问题解决方案协助开发ls-lint配置包时发现了特殊情况，使用之前的开发方法错误的，别的项目引入配置包后检测不到ls-lint这个命令。经过多次实验查找问题怀疑可能跟ls-lint设计与eslint等有区别，导致ls-lint间接引用的话，命令没有被正确导出到.bin目录。由此提出解决方案为，在配置包写一个node脚本，别的项目通过执行脚本的方式间接执行ls-lint命令。需要额外操作的步骤如下：a. 编写一个node脚本运行想要运行的命令（以下为ls-lint的例子）\n123456789101112#!/usr/bin/env nodeconst &#123; execSync &#125; = require(&#x27;child_process&#x27;);const path = require(&#x27;path&#x27;);const lsLintPath = path.join(__dirname, &#x27;node_modules&#x27;, &#x27;.bin&#x27;, &#x27;ls-lint&#x27;);try &#123;  const result = execSync(`$&#123;lsLintPath&#125;`).toString();  console.log(result);&#125; catch (error) &#123;  // `error.message` should contain the output of the `ls-lint` command.  // console.error(error.message);  process.exit(1); // Exit with an error status code.&#125;\n\nb. 在package.json文件中添加bin字段，设置命令引入js脚本文件（以下为ls-lint的例子）\n123&quot;bin&quot;: &#123;  &quot;ls-lint&quot;: &quot;./ls-lint.js&quot;&#125;\n","slug":"npm-package","date":"2023-12-01T10:03:07.000Z","categories_index":"前端技术","tags_index":"npm,eslint,stylelint","author_index":"Carlos Lee"},{"id":"cefb58a49db29b921cfdff3db3cce51b","title":"Git 常用指令","content":"本地操作提交git add —–⼯作区提交到暂存区1231 git add .               将所有修改⽂件都提交到暂存区2 git add ./a.js ./b.js   将修改的⽂件中的指定的⽂件3 git add ./js            将js⽂件夹下修改的内容提交到暂存区\n\ngit commit —–⼯作区内容提交到本地仓库121 git commit -m &quot;your commit message&quot;   将⼯作区内容提交到本地仓库,并添加提交信息2 git commit -m &quot;new message&quot; --amend   将⼯作区内容提交到本地仓库并追加提交\n\ngit push —–将本地仓库的内容推送到远程仓库1231 git push                                将当前本地分⽀branch1内容推送到远程分⽀or2 git push --set-upstream origin branch1  若当前本地分⽀branch1 没有对应的远程分⽀or3 git push -f                             强制提交\n\n新建11 git init  新建仓库\n\n合并git merge —–将其他分⽀合并到⽬前所在分⽀⾥边11 git merge &lt;某个分⽀名&gt;    将某个分⽀合并到当前分⽀\n\ngit rebase —–简洁commit记录，多次commit合并为⼀次11 git rebase -i   合并多次commit为⼀次，只能在⾃⼰的分⽀上操作\n\ngit cherry-pick —–合并指定的commit到当前分⽀12345671 git cherry-pick commit-sha1             将commit-sha1的变动和并到当前分⽀2 git cherry-pick commit-sha1 commit-sha2 将多次commit变动合并到当前分⽀3 git cherry-pick commit-sha1..comit-sah5 将commit-sha1到commit-sha5中间的所有的变动4 git cherry-pick --continue              pick时解决冲突后继续pick5 git cherry-pick --skip                  多次pick时跳过本次commit的pick进⼊下⼀个co6 git cherry-pick --abort                 完全放弃pick 恢复pick之前的状态7 git cherry-pick --quit                  未冲突的commit⾃动变更，冲突的不要，推出这次\n\n回撤git revert —–取消某次commit的内容（取消某次commit更改的内容，但是不会取消commit的记录⽽是⽤新⼀次的commit进⾏覆盖）121 git revert &lt;commit_sha&gt;     取消某次commit内容但是会保留commit的记录2 git revert -m 1 &lt;merge_sha&gt; 取消某次merge\n\ngit reset —–回滚代码1231 git reset --mixed &lt;commit_sha&gt;  将本地仓库退回⼯作区（取消commit 和add操作，不改变⽂件2 git reset --sort &lt;commit_sha&gt;   将某个版本的commit从本地仓库退回到缓存区（取消commit）3 git reset --hard &lt;commit_sha&gt;   取消某次commit的记录（取消commit和add并且改变⽂件）\n\ngit restore —–撤销缓存（⽤于将改动从暂存区退回⼯作区）121 git restore --staged a.js   将a.js⽂件取消缓存(取消add操作，不改变⽂件内容)2 git restore --staged .      将所有⽂件取消缓存\n\n缓存git stash —–缓存代码123456781 git stash save &quot;message&quot;  缓存代码时添加备注，便于查找。强烈推荐2 git stash list            查看缓存记录3 git stash pop             取出上⼀次缓存的代码，并删除这次缓存4 git stash pop stash@&#123;2&#125;   取出index为2的缓存，并删除这次缓存，index为对应的git stas5 stash apply               取出上⼀次的缓存，但不删除这次缓存6 git stash apply stash@&#123;2&#125; 取出index为2的缓存代码，但不删除缓存7 git stash drop stash@&#123;n&#125;  清除某次的缓存8 git stash clear           清除所有缓存\n\n查看git diff —–对⽐差异12341 git diff                      当⼯作区有变动，暂存区⽆变动，对⽐⼯作区和本地仓库的差异；2 git diff --cached             显⽰暂存区和本地仓库间的代码管理3 git diff --staged             和上⼀条⼀样4 git diff &lt;分⽀名1&gt; &lt;分⽀名2&gt;   显⽰两个分⽀之间的差异\n\ngit log12341 git log                     显⽰commit⽇志2 git log --oneline           以简要模式显⽰commit的⽇志3 git log -n                  显⽰最近n次的commit⽇志4 git log --graph --decorate  显⽰commit 及分⽀的图形化变更\n\ngit status —— 查看⼯作区状态1231 git status                查看当前⼯作区暂存区变动2 git status -s             以概要形式查看⼯作区暂存区变动3 git status --show-statsh  查询⼯作区是否有stash缓存\n\n全局配置配置⽤⼾信息1231 git config user.name &quot;your name&quot;      配置⽤⼾名2 git config user.email &quot;your email &quot;   配置⽤⼾邮箱3 git config --global --list            查看当前配置\n\n远程拉取git fetch —获取更新121 git fetch &lt;远程主机名&gt; &lt;分⽀名&gt;   获取远程特定分⽀的更新2 git fetch --all                  获取远程仓库所有分⽀的更新\n\ngit clone —克隆仓库1231 git clone &lt;git url &gt;              克隆远端仓库到本地2 git clone &lt;git url &gt; -b branch1   克隆远端仓库到本地，并同时切换到指定分⽀ branch13 git clone &lt;git url &gt; my-project   克隆远端仓库到本地并指定本地仓库的⽂件夹名称为my-project\n\ngit pull —拉取远程仓库并合并1231 git pull                       若拉取并合并的远程分⽀和当前本地分⽀⼀致2 git pull &lt;远程主机名&gt; &lt;分⽀名&gt;  若拉取并合并的远程分⽀和当前本地分⽀名称不⼀致3 git pull --rebase              使⽤rebase模式进⾏合并\n\n关联git remote12341 git remote add origin &lt;git url&gt;       关联本地git init到远程仓库2 git remote add &lt;git url&gt;              新增其他上游仓库3 git remote remove &lt;git url &gt;          移除与远程仓库的管理4 git remote set-url origin &lt;git url&gt;   修改推送源\n\n分支管理git checkout —切换分⽀1234561 git checkout branch1        切换到已有的本地分⽀branch12 git checkout origin/branch1 切换到远程分⽀branch13 git checkout -b branch2 基于当前本地分⽀创建⼀个新的分⽀branch24 git checkout origin/branch1 -b branch2 基于远程分⽀branch1创建⼀个新的分⽀bra5 git checkout                撤销⼯作区所有内容的修改。危险操作，谨慎6 git checkout -- &lt;file&gt;      撤销⼯作区file内容的修改。危险操作，谨慎\n\ngit branch —管理分⽀123451 git branch -D &lt;分⽀名&gt;                    删除分⽀2 git branch -M &lt;⽼分⽀名&gt; &lt;新分⽀名&gt;        重命名分⽀3 git branch -m &lt;新分⽀名&gt;                  将当前分⽀重命名为新分⽀名4 git branch --set-upstream-to=origin/xxx   将本地分⽀与远程分⽀关联5 git branch --unset-upstream-to=origin/xxx 取消本地分⽀与远程分⽀的关联","slug":"git","date":"2023-07-21T06:00:00.000Z","categories_index":"git","tags_index":"git","author_index":"Carlos Lee"}]